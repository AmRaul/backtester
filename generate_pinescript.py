#!/usr/bin/env python3
"""
PineScript Code Generator for Backtester
Генерирует PineScript код из Python конфигурации
"""

import json
import argparse
from typing import Dict, Any
from pathlib import Path


class PineScriptGenerator:
    """Генератор PineScript кода из конфигурации"""

    def __init__(self, config: Dict[str, Any]):
        self.config = config
        self.strategy_name = config.get('symbol', 'Strategy').replace('/', '')
        self.timeframe = config.get('timeframe', '15m')
        self.execution_timeframe = config.get('execution_timeframe')
        self.order_type = config.get('order_type', 'long').upper()

    def generate(self) -> str:
        """Генерирует полный PineScript код"""
        code_sections = [
            self._generate_header(),
            self._generate_inputs(),
            self._generate_indicators(),
            self._generate_entry_logic(),
            self._generate_dca_logic(),
            self._generate_exit_logic(),
            self._generate_plot()
        ]

        return "\n\n".join(code_sections)

    def _generate_header(self) -> str:
        """Генерирует заголовок стратегии"""
        initial_capital = self.config.get('start_balance', 10000)
        leverage = self.config.get('leverage', 1)
        commission = self.config.get('commission_rate', 0.0004) * 100  # В процентах
        dca_enabled = self.config.get('dca', {}).get('enabled', False)
        max_dca = self.config.get('dca', {}).get('max_orders', 5)
        pyramiding = max_dca + 1 if dca_enabled else 1
        calc_on_order_fills = self.config.get('calc_on_order_fills', True)

        header = f"""// This strategy was automatically generated by Python Backtester
// Symbol: {self.config.get('symbol', 'N/A')}
// Timeframe: {self.timeframe}
// Generated: Auto-generated

//@version=5
strategy(
    title="{self.strategy_name} DCA Strategy",
    shorttitle="{self.strategy_name}",
    overlay=true,
    initial_capital={initial_capital},
    default_qty_type=strategy.percent_of_equity,
    default_qty_value={self.config.get('first_order', {}).get('amount_percent', 10)},
    commission_type=strategy.commission.percent,
    commission_value={commission:.4f},
    pyramiding={pyramiding},
    calc_on_order_fills={str(calc_on_order_fills).lower()},
    calc_on_every_tick=false,
    process_orders_on_close=false
)"""

        return header

    def _generate_inputs(self) -> str:
        """Генерирует входные параметры"""
        inputs = ["// ==================== INPUTS ===================="]

        # Strategy Settings
        inputs.append("\n// Strategy Settings")
        inputs.append(f"orderType = input.string('{self.order_type}', 'Order Type', options=['LONG', 'SHORT'])")

        # Execution timeframe
        if self.execution_timeframe:
            inputs.append(f"executionTF = '{self.execution_timeframe}'")
            inputs.append(f"// Note: Chart timeframe should be set to {self.timeframe} for strategy signals")

        # First Order
        first_order = self.config.get('first_order', {})
        percent = first_order.get('amount_percent', 10)
        inputs.append(f"\n// First Order Settings")
        inputs.append(f"firstOrderPercent = input.float({percent}, 'First Order % of Balance', minval=1, maxval=100)")

        # DCA Settings
        dca_config = self.config.get('dca', {})
        if dca_config.get('enabled', False):
            inputs.append(f"\n// DCA Settings")
            inputs.append(f"dcaEnabled = input.bool(true, 'Enable DCA')")
            inputs.append(f"maxDcaOrders = input.int({dca_config.get('max_orders', 5)}, 'Max DCA Orders', minval=1, maxval=20)")

            step_percent = dca_config.get('step_price', {}).get('value', 2.0)
            inputs.append(f"dcaStepPercent = input.float({step_percent}, 'DCA Step %', minval=0.1, maxval=10.0)")

            multiplier = dca_config.get('martingale', {}).get('multiplier', 1.5)
            inputs.append(f"dcaMultiplier = input.float({multiplier}, 'DCA Multiplier', minval=1.0, maxval=5.0)")

            progression = dca_config.get('martingale', {}).get('progression', 'exponential')
            inputs.append(f"dcaProgression = input.string('{progression}', 'DCA Progression', options=['exponential', 'linear', 'fibonacci'])")
        else:
            inputs.append(f"\n// DCA Disabled")
            inputs.append(f"dcaEnabled = false")

        # Take Profit
        tp_config = self.config.get('take_profit', {})
        if tp_config.get('enabled', True):
            inputs.append(f"\n// Take Profit Settings")
            inputs.append(f"tpEnabled = input.bool(true, 'Enable Take Profit')")
            inputs.append(f"tpPercent = input.float({tp_config.get('percent', 3.0)}, 'Take Profit %', minval=0.1, maxval=100.0)")

            tp_trailing = tp_config.get('trailing', {})
            if tp_trailing.get('enabled', False):
                inputs.append(f"tpTrailingEnabled = input.bool(true, 'Enable Trailing TP')")
                inputs.append(f"tpTrailingActivation = input.float({tp_trailing.get('activation_percent', 3.0)}, 'TP Trail Activation %')")
                inputs.append(f"tpTrailingPercent = input.float({tp_trailing.get('trail_percent', 1.0)}, 'TP Trail %')")
        else:
            inputs.append(f"\n// Take Profit Disabled")
            inputs.append(f"tpEnabled = false")

        # Stop Loss
        sl_config = self.config.get('stop_loss', {})
        if sl_config.get('enabled', False):
            inputs.append(f"\n// Stop Loss Settings")
            inputs.append(f"slEnabled = input.bool(true, 'Enable Stop Loss')")
            inputs.append(f"slPercent = input.float({sl_config.get('percent', 10.0)}, 'Stop Loss %', minval=0.1, maxval=100.0)")
        else:
            inputs.append(f"\n// Stop Loss Disabled")
            inputs.append(f"slEnabled = false")

        # Indicators
        indicators_config = self.config.get('indicators', {})
        if indicators_config.get('enabled', False):
            inputs.append(f"\n// Indicator Settings")

            # RSI
            rsi_config = indicators_config.get('rsi', {})
            if rsi_config.get('enabled', False):
                inputs.append(f"rsiEnabled = input.bool(true, 'Use RSI')")
                inputs.append(f"rsiPeriod = input.int({rsi_config.get('period', 14)}, 'RSI Period')")
                inputs.append(f"rsiOversold = input.float({rsi_config.get('oversold', 30)}, 'RSI Oversold')")
                inputs.append(f"rsiOverbought = input.float({rsi_config.get('overbought', 70)}, 'RSI Overbought')")

            # EMA
            ema_config = indicators_config.get('ema', {})
            if ema_config.get('enabled', False):
                inputs.append(f"emaEnabled = input.bool(true, 'Use EMA')")
                inputs.append(f"emaFastPeriod = input.int({ema_config.get('fast_period', 9)}, 'EMA Fast')")
                inputs.append(f"emaSlowPeriod = input.int({ema_config.get('slow_period', 21)}, 'EMA Slow')")

        return "\n".join(inputs)

    def _generate_indicators(self) -> str:
        """Генерирует расчет индикаторов"""
        indicators = ["// ==================== INDICATORS ===================="]

        indicators_config = self.config.get('indicators', {})

        # Определяем использует ли стратегия dual timeframe
        if self.execution_timeframe:
            security_func = f"request.security(syminfo.tickerid, '{self.timeframe}', "
            indicators.append(f"\n// Using Dual Timeframe: Chart={self.execution_timeframe}, Strategy={self.timeframe}")
        else:
            security_func = ""

        if indicators_config.get('enabled', False):
            # RSI
            rsi_config = indicators_config.get('rsi', {})
            if rsi_config.get('enabled', False):
                if self.execution_timeframe:
                    indicators.append(f"rsi = {security_func}ta.rsi(close, rsiPeriod))")
                else:
                    indicators.append(f"rsi = ta.rsi(close, rsiPeriod)")

            # EMA
            ema_config = indicators_config.get('ema', {})
            if ema_config.get('enabled', False):
                if self.execution_timeframe:
                    indicators.append(f"emaFast = {security_func}ta.ema(close, emaFastPeriod))")
                    indicators.append(f"emaSlow = {security_func}ta.ema(close, emaSlowPeriod))")
                else:
                    indicators.append(f"emaFast = ta.ema(close, emaFastPeriod)")
                    indicators.append(f"emaSlow = ta.ema(close, emaSlowPeriod)")
        else:
            indicators.append("// No indicators enabled")

        return "\n".join(indicators)

    def _generate_entry_logic(self) -> str:
        """Генерирует логику входа"""
        logic = ["// ==================== ENTRY LOGIC ===================="]

        entry_config = self.config.get('entry_conditions', {})
        entry_type = entry_config.get('type', 'immediate')
        indicators_config = self.config.get('indicators', {})

        # Базовые условия входа
        if indicators_config.get('enabled', False):
            conditions = []

            # RSI
            rsi_config = indicators_config.get('rsi', {})
            if rsi_config.get('enabled', False):
                if self.order_type == 'LONG':
                    conditions.append(f"rsi < rsiOversold")
                else:  # SHORT
                    conditions.append(f"rsi > rsiOverbought")

            # EMA
            ema_config = indicators_config.get('ema', {})
            if ema_config.get('enabled', False):
                if self.order_type == 'LONG':
                    conditions.append(f"emaFast > emaSlow")
                else:  # SHORT
                    conditions.append(f"emaFast < emaSlow")

            if conditions:
                logic.append(f"entryCondition = {' and '.join(conditions)}")
            else:
                logic.append(f"entryCondition = true  // No specific conditions")
        else:
            if entry_type == 'immediate':
                logic.append(f"entryCondition = true  // Immediate entry")
            else:
                logic.append(f"entryCondition = true  // Manual entry conditions")

        # Entry execution
        logic.append(f"\n// Entry Execution")
        logic.append(f"if entryCondition and strategy.position_size == 0")
        if self.order_type == 'LONG':
            logic.append(f"    strategy.entry('LONG', strategy.long)")
        else:
            logic.append(f"    strategy.entry('SHORT', strategy.short)")

        return "\n".join(logic)

    def _generate_dca_logic(self) -> str:
        """Генерирует логику DCA"""
        dca_config = self.config.get('dca', {})

        if not dca_config.get('enabled', False):
            return "// DCA Disabled"

        logic = ["// ==================== DCA LOGIC ===================="]

        logic.append("""
// Calculate DCA quantity based on progression
getDcaQuantity(level) =>
    baseQty = strategy.equity * firstOrderPercent / 100 / close
    multiplier = 1.0

    if dcaProgression == 'exponential'
        multiplier := math.pow(dcaMultiplier, level)
    else if dcaProgression == 'linear'
        multiplier := 1 + (dcaMultiplier - 1) * level
    else if dcaProgression == 'fibonacci'
        // Fibonacci sequence
        if level == 0
            multiplier := 1
        else if level == 1
            multiplier := 1
        else
            fib1 = 1.0
            fib2 = 1.0
            for i = 2 to level
                temp = fib2
                fib2 := fib1 + fib2
                fib1 := temp
            multiplier := fib2

    baseQty * multiplier

// DCA Entry Conditions
dcaLevel = strategy.opentrades - 1  // Current DCA level (0 = first entry)
canDca = dcaEnabled and dcaLevel < maxDcaOrders and strategy.position_size != 0

if canDca
    avgPrice = strategy.position_avg_price
    currentPrice = close

    if orderType == 'LONG'
        priceDrop = (avgPrice - currentPrice) / avgPrice * 100
        if priceDrop >= dcaStepPercent
            dcaQty = getDcaQuantity(dcaLevel)
            strategy.entry('DCA_' + str.tostring(dcaLevel), strategy.long, qty=dcaQty)

    else  // SHORT
        priceRise = (currentPrice - avgPrice) / avgPrice * 100
        if priceRise >= dcaStepPercent
            dcaQty = getDcaQuantity(dcaLevel)
            strategy.entry('DCA_' + str.tostring(dcaLevel), strategy.short, qty=dcaQty)
""")

        return "\n".join(logic)

    def _generate_exit_logic(self) -> str:
        """Генерирует логику выхода"""
        logic = ["// ==================== EXIT LOGIC ===================="]

        tp_config = self.config.get('take_profit', {})
        sl_config = self.config.get('stop_loss', {})

        logic.append("""
if strategy.position_size != 0
    avgPrice = strategy.position_avg_price
    currentPrice = close

    if orderType == 'LONG'
        profitPercent = (currentPrice - avgPrice) / avgPrice * 100
        lossPercent = (avgPrice - currentPrice) / avgPrice * 100

        // Take Profit
        if tpEnabled and profitPercent >= tpPercent
            strategy.close_all(comment='TP')

        // Stop Loss
        if slEnabled and lossPercent >= slPercent
            strategy.close_all(comment='SL')

    else  // SHORT
        profitPercent = (avgPrice - currentPrice) / avgPrice * 100
        lossPercent = (currentPrice - avgPrice) / avgPrice * 100

        // Take Profit
        if tpEnabled and profitPercent >= tpPercent
            strategy.close_all(comment='TP')

        // Stop Loss
        if slEnabled and lossPercent >= slPercent
            strategy.close_all(comment='SL')
""")

        return "\n".join(logic)

    def _generate_plot(self) -> str:
        """Генерирует отображение на графике"""
        plot = ["// ==================== PLOT ===================="]

        indicators_config = self.config.get('indicators', {})

        if indicators_config.get('enabled', False):
            # EMA
            ema_config = indicators_config.get('ema', {})
            if ema_config.get('enabled', False):
                plot.append("plot(emaFast, 'EMA Fast', color=color.blue, linewidth=2)")
                plot.append("plot(emaSlow, 'EMA Slow', color=color.red, linewidth=2)")

            # RSI в отдельном окне не выводим, но можно добавить

        # Отображаем среднюю цену позиции
        plot.append("""
// Plot average position price
plot(strategy.position_size != 0 ? strategy.position_avg_price : na,
     'Avg Price', color=color.yellow, linewidth=2, style=plot.style_linebr)
""")

        plot.append("\n// Generated by Python Backtester - PineScript Generator")

        return "\n".join(plot)


def main():
    """Основная функция"""
    parser = argparse.ArgumentParser(description='Generate PineScript code from Python config')
    parser.add_argument('config', help='Path to config JSON file')
    parser.add_argument('-o', '--output', help='Output file path (default: stdout)')
    args = parser.parse_args()

    # Загружаем конфигурацию
    config_path = Path(args.config)
    if not config_path.exists():
        print(f"Error: Config file '{args.config}' not found")
        return 1

    with open(config_path, 'r', encoding='utf-8') as f:
        config = json.load(f)

    # Генерируем код
    generator = PineScriptGenerator(config)
    pinescript_code = generator.generate()

    # Выводим результат
    if args.output:
        output_path = Path(args.output)
        output_path.parent.mkdir(parents=True, exist_ok=True)
        with open(output_path, 'w', encoding='utf-8') as f:
            f.write(pinescript_code)
        print(f"✅ PineScript code generated: {output_path}")
    else:
        print(pinescript_code)

    return 0


if __name__ == '__main__':
    exit(main())
